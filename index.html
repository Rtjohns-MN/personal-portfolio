
<!DOCTYPE html>
<html>
<head>
    <title>Robert Johnson Portfolio Site - Home</title>
    <link rel="stylesheet" type="text/css" href="styles.css">
    <script src="https://code.jquery.com/jquery-1.10.2.js"></script>
</head>
<body>
    <!--Navigation bar by Ramtin on stackoverflow-->
    <div id="nav-placeholder">

    </div>

    <script>
    $(function(){
      $("#nav-placeholder").load("nav.html");
    });
    </script>
    <!--end of Navigation bar-->
    <content>
    <h1>Introduction</h1>
    <p>This website is a space to present all of the work I've done in 
    various classes for school and personal works. Each subpage contains 
    more detail about each individual project and links to any elements 
    which are presentable. The websites I created for school have the 
    site links to each of their respective pages.</p>
    <div class="spacer"></div>
    
    <h2>Class Details</h2>
    <p>A number of classes I've taken have relevance to different fields
    and I explain the rough content which was discussed in each of the classes. 
    Many of them have related school projects and those are discussed briefly 
    on the class page and more in depth on the School Projects page.</p>
    
    <h2>School Projects</h2>
    <p>Each of the school projects were created during the course of the 
    classes I've taken. The details for each specific project is explained 
    in full detail and links lead to the actual projects themselves.</p>
    
    <h2>Personal Works</h2>
    <p>My personal works are the various projects I have created on my 
    own time. The projects themselves were created out of personl interest 
    in the topic or due to my desire to create something using the skills 
    which I have learned over the years.</p>
    <hr>
    
    <div id="toc_block">
    <div id="toc_container">
    <h1>Table of Contents</h1>
    <ul class="toc_list">
        <li><a href="#index_topic_1">1 Object Oriented Programming</a></li>
        <li><a href="#index_topic_2">2 Solving Technical Problems</a></li>
        <li><a href="#index_topic_3">3 UML Diagrams</a></li>
        <li><a href="#index_topic_4">4 Code Testing</a></li>
        <li><a href="#index_topic_5">5 RESTful APIs</a></li>
        <li><a href="#index_topic_6">6 Software Development Life Cycle</a></li>
        <li><a href="#index_topic_7">7 Relational Databases</a></li>
    </ul>
    </div>
    </div>
    <hr>

    <h1 id="index_topic_1">Object Oriented Programming</h1>
    <p>Object Oriented Programming is a style of programming which makes 
    use of objects which contain data. These objects can encompass a 
    huge variety of types: accounts, geographic data, shape representations.
    Objects are generally defined by a structure called a class. A 
    class contains the attritubes and methods which an object uses to 
    store and manipulate its data. An object itself is a member of the 
    class, but the object itself is just one member of many objects which 
    are that class.</p>
    <br>
    <h2>Four Pillars of OOP</h2>
    
    <table><tr><th>
        <ul class="pillars">
            <li>Encapsulation</li>
            <li>Data Abstraction</li>
            <li>Inheritance</li>
            <li>Polymorphism</li>
        </ul>
        </th>
        </tr>
    </table>
    <p>The four major principles of OOP are used to created more 
    orgranized, functional and understandable programs. </p>
    <h2>Encapsulation</h2>
    <p>Encapsulation is when we restrict access to the variables within 
    a class by making them private. Instead we use public methods which 
    return or change the values of that class. As this prevents direct 
    access to the data we can add more control over how the data is 
    retrieved/changed during runtime.</p>
    
    <h2>Data Abstraction</h2>
    <p>Abstraction is when we build classes in a way which allows 
    one class to make use of the functionality of a second class without 
    needing that first class to have any detailed information about how 
    that second class works internally.</p>
    
    <h2>Inheritance</h2>
    <p>Inheritance is when we use parent classes with more specific 
    subclasses so that each sub-class has the parents components, but 
    can also have its own components specific to itself. This allows us 
    to build the parent methods only once, and reuse them for each 
    sub-class. The relationship between these 2 classes is a "is-a" 
    relationship. If a class contains another class then it's a "has-a" 
    relationship.</p>
    
    <h2>Polymorphism</h2>
    <p>Polymorphism allows us to use inherited classes to treat them as 
    the same type of class, regardless of how they have been modified. 
    EXAMPLE: Any food can be eaten, but some are eaten using hands or 
    utensils. Utensils are more common so we set that as the default 
    means. If the food is eaten using hands then the method which is 
    used to eat the food is overriden and changed to eat using hands.</p>
    <div><br></div>   
    <hr>
    
    <h1 id="index_topic_2">Solving Technical Problems</h1>
    <p>In software technical problems occur sometimes as design choices 
    can lead to unforseen errors. To resolve these errors we should follow 
    a procedure.</p>
    <h2>Gather Information</h2>
    <p>The first step is to gather all of the information we have about 
    the problem. If the issue was reported by someone else ask that person 
    all the relevant questions about the problem. Good questions to ask are 
    <br>What were you doing just before the problem occured?
    <br>Do any error messages come up when the error happens and what do they say?
    <br>How often does this problem occur?
    <br>Does anyone else who uses the software have this problem?
    <br>Is there a set of steps to trigger the problem?</p>
    <h2>Find the Problem Trigger</h2>
    <p>Test the system to find a way to trigger the error on your version 
    of the system. This confirms that the problem exists within the system 
    itself and may give a hint as to where the problem resides. If the 
    client gave information about the problem use that to help trigger 
    the error. It would help to use some type of process tracking program 
    to give some additional information when the error occurs.</p>
    <h2>Isolate the Problem</h2>
    <p>The third step is figuring out where the problem is in the system. 
    Use any information from the previous steps to help determine what area 
    the problem is in. Once you think you have found the general area/cause 
    isolate that section of the system and try to trigger the error. If the 
    error occurs as before, then we have located the general area of the error 
    and can further isolate the system to find the exact cause of the error. If 
    the error does NOT occur when isolated that means that a larger section 
    of the system contains the error. While more difficult to resolve, we can 
    still examine the steps the program is taking which causes the error.<br>
    During this process it may help to use some types of data reporting to 
    gain additional information during the error. The actual data to track 
    depends on the type of error.</p>
    <h2>Plan a Solution</h2>
    <p>Once you've found the location of the problem you need to determine 
    a solution for it. Some errors are quick to resolve, and may just need 
    a couple lines of code to fix, while more complex ones require a larger 
    reaching solution. Planning a solution helps avoid creating additional 
    problems while fixing this one. Errors can potentially cascade into a larger spiral 
    of problems, which can undermine the system as a whole. Make sure to document 
    the changes made for the solution so that in case the fix causes more problems 
    you can revert to the previous state and try a different solution.</p>
    <h2>Implement and Test Solution</h2>
    <p>Follow the planned steps to fix the error and then run the relevant 
    tests on the system to ensure that the error is fixed and then that 
    it did not cause any additional errors. While it may seem redundant to 
    test the entirety of the system, catching errors before they are sent 
    out to clients is a huge priority.</p>
    <h2>Deploy the Solution to Clients</h2>
    <p>The updates need to be sent to the clients so that the error no 
    longer occurs for them as well. You should ensure that the client 
    which reported the error has the problem fixed as well.</p>
    <hr>
    
    <h1 id="index_topic_3">UML Diagrams</h1>
    <p>UML diagrams can be used for a number of different things but the
    experience I've had was using them to represent class diagrams for 
    programs.</p>
    <h2>Objects</h2>
    <p>Objects are represented by boxes with text. The object box is generally 
    split into three separate boxes: title, attributes, and actions. <br>
    The title displays the object name and can have the type as well. An object name
    in italics is a abstract class, which itself will have no defined objects, but
    have representative sub classes which do have defined instances.<br>
    The attributes list the parameters and objects used by the class. 
    Often they have the associated type for each parameter listed as well 
    as its name, and value. A + by the name indicates that the attribute 
    is public, while a - represents a private attribute.<br>
    Actions are the methods and functions which the class can perform. 
    It should list the name, parameters, and possibly the output of the 
    function.</p>
    <h2>Relationship Arrows</h2>
    <p>Relationships between classes are defined using different types of arrows.
    A solid arrow indicates that the class uses the target class. An arrow with 
    dashes or a hollow head means that the class is a subclass of the parent class. 
    A line with a diamon head is an aggregate of the class, meaning that it 
    contains many of that object in that class.</p>
    <hr>
    
    <h1 id="index_topic_4">Code Testing</h1>
    <p>Code testing is done to ensure that the program passes all of the
    required tasks, even as changes are made to the system. Common types of 
    testing includes Unit, Integration, Validation, Regression, Load, and Stress tests. 
    Tests often use an assert function which takes a conditional statement 
    and returns passed or failed based on if the conditional statement resulted in
    true or false. Inside the conditional statement the parts being tested are the
    method with proper parameters while on the other side is the resultant value it 
    should (or shouldn't) return with.</p>
    <table id="t_descr">
        <tr><td>Unit Testing</td><td>Unit Testing involves writing tests which examine the behaviors of each 
        individual object (a unit). A unit test checks the return parameters for the 
        methods of the unit.
        <br>EX: assert(adder.add(1,1)==2)</td>
        </tr>
        <tr><td>Integration Testing</td><td>Integration Testing examines the behavior of the combined units 
        of the system, testing the units interacting with each other. As integration testing has
        a large number of parts coming together it can be handled with a number of styles:
        risky-hardest, top-down, bottom-up, mixed.
        <br>EX: assert(equiv(addr(1,1),subt(2,1))==true)</td>
        </tr>
        <tr><td>Validation Verification Testing</td><td>Validation Testing is used to determine if the system meets the 
        requirements and fulfills the intended purpose. This also relates to verification testing which 
        is used to determine if the system is built correctly, IE without bugs or errors.
        Essentially Verification is asking "are we building the product correctly?" while 
        Validation is asking "are we building the right product?"</td>
        </tr>
        <tr><td>Regression Testing</td><td>Regression Testing is running all of the tests after an update 
        to ensure that the changes made to the system still passes those tests. Failing the regression test 
        means that the system has 'regressed' and must be fixed before proceeding forward.</td>
        </tr>
        <tr><td>Load Testing</td><td>Load Testing involves using the system with various access loads 
        to determine the effects at those load levels. A load can be multiple things: a number of users 
        using the system simultaneously, it can be the number of objects which exist, or a number 
        of requests from various other sources. To test do a load test we need to have an automated 
        exterior system which acts as the load which performs each task.
        <br>EX: 25 virtual users log in, browse through items and then log off.</td>
        </tr>
        <tr><td>Stress Testing</td><td>Stress Testing generally involves the testing the physical 
        limits of the system, often memory and CPU. Stress testing examines the behavior of the 
        system when it is at its limit and beyond. What happens when too many users log on? What
        happens when there are more accounts then there are ID values for? What happens when an
        integer value tips over the highest number?</td>
        </tr>
    </table>
    <p>More types of testing exist beyond these, but the core of every system should at least acknowledge these
    6 types. These tests should be thorough enough to ensure that the system will not fail in the normal 
    usage, but they do not need to cover 100% of potential cases. Most systems can function acceptably well
    with 70% test functionality. The most important cases to examine with tests are the edge cases. An example
    edge case would be the divide by 0 error. </p>
    
    <h2>Error Handling</h2>
    <p>Another important part of testing is handling errors. When an error does occur what should the system
    do? Should it crash or continue working? Should it open a dialogue box notifying the user or system? Should
    it automatically handle the error and simply work around it?</p>
    <p>If we know an error exists we can create a Try Catch container which can change how 
    the system responds to that error. By placing the code which creates the error in the Try 
    section it can then check to see if it hits an error by setting a Catch response 
    targetted at that particular error. This allows us to change how that error is handled 
    by say, returning a different value instead.</p>
    <p>Example Error Handling<br>
    In the Tabletop Manager application users can enter values for the action stats which are
    automatically summed up into a total. If the user compeletely deletes the entry for the 
    value then the system returns Not a Number to the sum which crashes the application. 
    In order to handle this error I set the system to respond instead by sending 0 to the
    sum total which prevents the crash.</p>
    <hr>
    
    <h1 id="index_topic_5">RESTful APIs</h1>
    <p>REST is an acronym for REpresentational State Transfer and is an
    architectual style for distributed hypermedia systems. There are 6 
    guiding constraints for using the REST style which are as follows.</p>
    <p>1 Client-server: separating the user interface elements and the data 
    management elements the entire system becomes more portable. Effectively,
    different user interfaces can send messages to perform the same tasks
    as they are referencing the same calls inside of the data management section.</p>
    <p>2 Stateless: Session state is kept entirely by the client. This means that 
    any request sent by the client contains all of the relevant information 
    which the data manager needs to perform the action requested.</p>
    <p>3 Cacheable: All data is labeled either cacheable or non-cacheable. 
    Effectively asking if the data should be saved to be reused or if it 
    is single use and not to be saved.</p>
    <p>4 Uniform Interface: Using the software engineering principle of 
    generality to the component interface, the system is simpified and improved.
    Simply put, the interface should be consistent, and retain common elements.
    This reduces the need to teach new functions, and quickens familiarity with the
    system as a whole.<br>
    Four Major Constriants for the Interface: identification of resources; 
    manipulation of resources through representations; self-descriptive messages;
    hypermedia as the engine of application state.</p>
    <p>5 Layered System: Restrain component behavior to the each individual 
    layer to reduce redundancy and errors.</p>
    <p>6 Code on Demand (optional): allow extendability in the form of 
    applets or scripts. This adds modularity under the control of the user 
    so the core system can have a reduced number of provided features.</p>
    <h2>Managing Resources</h2>
    <p>Resources represent information which can be name inside of the system: 
    a document, an image, a collection of other resources, a person, and so on. 
    Every resource has some type of identifier to allow interaction between the 
    components of the system. Each resource needs a type to help the user or 
    system understand what the resouce is and how to use it.</p>
    <p>When managing resources the system will use the HTTP methods of 
    GET/PUT/POST/DELETE. While these methods have their own circumstances 
    they are not a lone handler to the task. Resource information needs to
    be tested and interpretted. Any query for resources should be a list of 
    links to that resource with addition information about it, not simply a 
    list of the resources. This is because each individual resource does not properly
    represent the information on its own.</p>
    <hr>

    <h1 id="index_topic_6">Software Development Life Cycle</h1>
    <h2>7 steps of the Software Development Life Cycle</h2>
    <table id="t_descr">
        <tr><td>1</td><td>Planning</td><td>The planning phase involves determining resources required for the project 
        as in people, cost, equipment, and deciding on a schedule.</td>
        </tr>
        <tr><td>2</td><td>Requirements</td><td>The requirements phase is when the team works with the clients/SMEs 
        to create the requirements documentation.</td>
        </tr>
        <tr><td>3</td><td>Design and Prototyping</td><td>Design and prototyping is the step when the team creates the class 
        diagrams and system overview. If needed they can create some prototypes 
        to test features and functionality.</td>
        </tr>
        <tr><td>4</td><td>Software Development</td><td>Software Development step is where the actual coding and development 
        process takes place.</td>
        </tr>
        <tr><td>5</td><td>Testing</td><td>The testing phase involves using tests to ensure that the product is 
        meeting the requirements and quality expected.</td>
        </tr>
        <tr><td>6</td><td>Deployment</td><td>Deploying the product should be done as soon as the project is ready. 
        Most projects also involve continuous deployment where even after 
        releasing the product, the team keeps updating the software.</td>
        </tr>
        <tr><td>7</td><td>Operations and Maintenance</td><td>The final step is ongoing operations and maintenance where the team 
        fixes problems discovered over time.</td>
        </tr>
    </table>
    <p>Two major methodologies exist to develop software. They both have advantages and disadvantages making
    neither really better than the other. Agile is currently more popular because of its flexibility, but 
    Waterfall is still used in some fields when strict process needs to be followed.</p>
    <h2>Waterfall Method</h2>
    <p>The Waterfall development process is where you do the entirety of each step in order and avoid going 
    back to previous steps as much as possible. It's a product of the factory production line 
    where the product is worked at each step, doing a specific task and then handed on. The 
    problem with this methodology is that when major problems are discovered down the line, the
    entire system may need to change which involves going backwards. The benefit of this method is
    that there is an overarching plan for the product, developed early on so everyone working on 
    it has a good idea of what they are doing and what comes next.</p>
    <h2>Agile/SCRUM</h2>
    <p>The Agile methodology involves repeating many steps in the process, checking that everything 
    works properly after each update. It also focuses on working with the client often to ensure that 
    they are getting what they want out of the product. Specifically Agile goes through steps 1 and 2 
    the same as waterfall, and then goes through steps 3, 4, and 5 repeatedly until the product is ready to 
    be deployed. The down side of this method is that it can descend into chaos if its not managed properly. 
    The upside is that it takes into account that there will need to be changes made and as it works closer 
    with the clients it creates a more personal product.</p>
    <hr>


    <h1 id="index_topic_7">Relational Databases</h1>
    <p>Relational databases are a method of storing information to 
    organize and easily retrieve that data. Using SQL you create tables with 
    multiple categories of information defining the entries within. Each 
    table has one category set as a unique identifier which specifies that 
    particular entry to have a reference point.</p>
    <p>SQL uses a SELECT statement to search for relevant information. The 
    SELECT statement uses 4 parts to find the information. The SELECT part 
    chooses what categories to show in the returned information. The FROM 
    chooses what tables to search, and JOIN can be used to combine tables. 
    WITH and Having can be used to enter filters to specify what you are looking
    for in the tables. And GROUP BY can be used to condense repetitive 
    data or sort the entries.</p>
    <p>5 aggregate functions can be used to change how the information is 
    returned. COUNT returns the number of rows, SUM returns the summative 
    value of the data, AVG gives the average, MIN and MAX return the 
    associated minimum or maximum value for the information.</p>
    <hr>
    </content>
</body>
</html>
